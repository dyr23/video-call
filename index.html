<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç²¾è‡´åœ£è¯æ ‘ - æ‰‹åŠ¿äº¤äº’ç‰ˆ</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js" type="module"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        #video-ui { position: absolute; bottom: 10px; left: 10px; width: 120px; height: 90px; border: 1px solid rgba(255,255,255,0.3); border-radius: 8px; overflow: hidden; z-index: 100; }
        #canvas-ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; transform: scaleX(-1); }
        video { display: none; }
        body { margin: 0; background: radial-gradient(circle, #1a2a6c, #b21f1f, #fdbb2d); } /* èŠ‚æ—¥æ°›å›´èƒŒæ™¯ */
    </style>
</head>
<body>
    <div id="status" class="absolute top-5 w-full text-center text-white z-50 text-sm font-bold">æ­£åœ¨å¬å”¤åœ£è¯æ ‘...</div>
    
    <div id="video-ui">
        <video id="input-video"></video>
        <canvas id="canvas-ui"></canvas>
    </div>

    <script type="module">
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js';

        let scene, camera, renderer, treeGroup;
        let lastHandX = null;
        const videoElement = document.getElementById('input-video');
        const canvasElement = document.getElementById('canvas-ui');
        const canvasCtx = canvasElement.getContext('2d');
        const statusText = document.getElementById('status');

        // --- 1. åˆå§‹åŒ– 3D åœºæ™¯ ---
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 3, 7);

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // ç¯å…‰è®¾ç½®
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const pointLight = new THREE.PointLight(0xffffff, 1);
        pointLight.position.set(5, 5, 5);
        scene.add(pointLight);

        // --- 2. åˆ›å»ºç²¾è‡´åœ£è¯æ ‘ ---
        treeGroup = new THREE.Group();

        // A. æ ‘å¹²
        const trunkGeom = new THREE.CylinderGeometry(0.2, 0.3, 1, 16);
        const trunkMat = new THREE.MeshPhongMaterial({ color: 0x5D4037 });
        const trunk = new THREE.Mesh(trunkGeom, trunkMat);
        trunk.position.y = 0.5;
        treeGroup.add(trunk);

        // B. äº”å±‚æ ‘å†  (å¢åŠ å±‚æ¬¡æ„Ÿ)
        const leafColors = [0x2D5A27, 0x366630, 0x3F7239, 0x487E42, 0x518A4B];
        for (let i = 0; i < 5; i++) {
            const levelGeom = new THREE.ConeGeometry(2 - i * 0.35, 1.2, 8);
            const levelMat = new THREE.MeshPhongMaterial({ 
                color: leafColors[i],
                flatShading: true // å¢åŠ åˆ‡å‰²è´¨æ„Ÿï¼Œçœ‹èµ·æ¥æ›´ç°ä»£
            });
            const level = new THREE.Mesh(levelGeom, levelMat);
            level.position.y = 1.2 + (i * 0.7);
            treeGroup.add(level);
        }

        // C. é¡¶éƒ¨çš„æ˜Ÿæ˜Ÿ
        const starGeom = new THREE.OctahedronGeometry(0.3, 0);
        const starMat = new THREE.MeshBasicMaterial({ color: 0xFFD700 });
        const star = new THREE.Mesh(starGeom, starMat);
        star.position.y = 4.8;
        treeGroup.add(star);

        // D. è£…é¥°å½©ç¯ (éšæœºåˆ†å¸ƒ)
        for (let i = 0; i < 30; i++) {
            const ballGeom = new THREE.SphereGeometry(0.08, 8, 8);
            const ballMat = new THREE.MeshPhongMaterial({ 
                color: Math.random() * 0xffffff,
                emissive: 0x222222 
            });
            const ball = new THREE.Mesh(ballGeom, ballMat);
            
            // éšæœºæ”¾åœ¨æ ‘å† è¡¨é¢
            const angle = Math.random() * Math.PI * 2;
            const radius = Math.random() * 1.5;
            const height = 1 + Math.random() * 3.5;
            ball.position.set(Math.cos(angle) * radius * (1 - height/5), height, Math.sin(angle) * radius * (1 - height/5));
            treeGroup.add(ball);
        }

        scene.add(treeGroup);

        // --- 3. æ‰‹åŠ¿è¯†åˆ« ---
        const hands = new Hands({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
        });

        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5 });

        hands.onResults((results) => {
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                statusText.innerText = "âœ¨ åœ£è¯é­”åŠ›ç”Ÿæ•ˆä¸­ - è¯·æŒ¥åŠ¨æ‰‹æŒ âœ¨";
                const hand = results.multiHandLandmarks[0];
                const currentX = hand[8].x; 

                // åœ¨é¢„è§ˆçª—ç”»çº¢ç‚¹
                canvasCtx.fillStyle = "#00FF00";
                canvasCtx.beginPath();
                canvasCtx.arc(currentX * canvasElement.width, hand[8].y * canvasElement.height, 5, 0, 2*Math.PI);
                canvasCtx.fill();

                if (lastHandX !== null) {
                    const deltaX = currentX - lastHandX;
                    // çµæ•åº¦ä¿æŒ 50ï¼Œç¡®ä¿å¿«é€Ÿæ—‹è½¬
                    treeGroup.rotation.y += deltaX * 50; 
                }
                lastHandX = currentX;
            } else {
                statusText.innerText = "ğŸ‘‹ è¯·å°†æ‰‹å±•ç¤ºåœ¨é•œå¤´å‰";
                lastHandX = null;
            }
        });

        const cameraObj = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 320, height: 240
        });
        cameraObj.start();

        function animate() {
            requestAnimationFrame(animate);
            // ç»™æ˜Ÿæ˜ŸåŠ ä¸€ç‚¹è‡ªè½¬
            star.rotation.y += 0.05;
            renderer.render(scene, camera);
        }
        animate();

        // é€‚é…å±å¹•
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
