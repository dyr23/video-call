<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>精致交互圣诞树 - 调优版</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; background: radial-gradient(circle at center, #050a1a 0%, #000 100%); overflow: hidden; }
        #canvas-ui { position: absolute; top: 15px; right: 15px; width: 70px; height: 90px; border: 1px solid rgba(0,255,0,0.3); border-radius: 10px; z-index: 100; transform: scaleX(-1); opacity: 0.6; }
    </style>
</head>
<body>
    <div id="overlay" class="absolute inset-0 z-[200] flex items-center justify-center bg-black/90">
        <div class="text-center">
            <button onclick="start()" class="border-2 border-white text-white px-10 py-4 rounded-full font-light tracking-[0.2em] text-lg hover:bg-white hover:text-black transition-all">
                ENTER EXPERIENCE
            </button>
        </div>
    </div>

    <div id="status" class="absolute top-12 w-full text-center text-white/50 z-50 text-xs tracking-[0.3em] uppercase pointer-events-none">Waiting for input...</div>
    <canvas id="canvas-ui"></canvas>
    <video id="input-video" style="display:none"></video>

    <script>
        let scene, camera, renderer, treeGroup;
        let lastX = null;
        let targetRotation = 0; // 目标旋转值
        let currentRotation = 0; // 当前旋转值
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();

        function init3D() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.position.set(0, 2, 8); 

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            scene.add(new THREE.AmbientLight(0xffffff, 1.2));
            
            treeGroup = new THREE.Group();
            // 【关键修改】树木缩小到 0.8，保证屏幕适配
            treeGroup.scale.set(0.8, 0.8, 0.8); 

            // 1. 树干
            const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.18, 1.2), new THREE.MeshPhongMaterial({color: 0x2b1d19}));
            treeGroup.add(trunk);

            // 2. 树冠
            for(let i=0; i<4; i++) {
                const leaf = new THREE.Mesh(
                    new THREE.ConeGeometry(1.6 - i*0.35, 1.2, 12),
                    new THREE.MeshPhongMaterial({color: 0x143d21, flatShading: true})
                );
                leaf.position.y = 1.0 + (i * 0.8);
                treeGroup.add(leaf);
                addPhoto(leaf.position.y, i);
            }
            scene.add(treeGroup);

            window.addEventListener('click', handleAction);
            window.addEventListener('touchstart', (e) => handleAction(e.touches[0]));
        }

        function addPhoto(y, index) {
            const loader = new THREE.TextureLoader();
            const tex = loader.load(`https://picsum.photos/400/500?random=${index + 50}`);
            const geo = new THREE.PlaneGeometry(0.7, 0.9);
            const mat = new THREE.MeshBasicMaterial({ map: tex, side: THREE.DoubleSide });
            const photo = new THREE.Mesh(geo, mat);
            
            const angle = (index * 2.2);
            const dist = 1.3 - (index * 0.1);
            photo.position.set(Math.cos(angle)*dist, y, Math.sin(angle)*dist);
            photo.lookAt(0, y, 0);
            
            photo.userData = { isPhoto: true, originalPos: photo.position.clone(), originalRot: photo.rotation.clone() };
            treeGroup.add(photo);
        }

        function handleAction(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(treeGroup.children);

            if (intersects.length > 0 && intersects[0].object.userData.isPhoto) {
                const obj = intersects[0].object;
                if(obj.scale.x === 1) {
                    obj.scale.set(2.5, 2.5, 2.5);
                    obj.position.set(0, 2, 3); 
                    obj.rotation.set(0, 0, 0);
                } else {
                    obj.scale.set(1, 1, 1);
                    obj.position.copy(obj.userData.originalPos);
                    obj.rotation.copy(obj.userData.originalRot);
                }
            }
        }

        async function start() {
            document.getElementById('overlay').style.display = 'none';
            init3D();
            const video = document.getElementById('input-video');
            const hands = new Hands({locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
            hands.setOptions({maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.6});
            
            hands.onResults(res => {
                const canvas = document.getElementById('canvas-ui');
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0,0,canvas.width,canvas.height);
                ctx.drawImage(res.image, 0,0,canvas.width,canvas.height);
                
                if(res.multiHandLandmarks && res.multiHandLandmarks.length > 0) {
                    const x = res.multiHandLandmarks[0][8].x;
                    if(lastX !== null) {
                        // 【速度修改】从 120 降到 35
                        targetRotation += (x - lastX) * 35; 
                    }
                    lastX = x;
                    document.getElementById('status').innerText = "TRACKING ACTIVE";
                } else {
                    lastX = null;
                    document.getElementById('status').innerText = "SHOW HAND TO START";
                }
            });
            const cam = new Camera(video, {onFrame: async () => {await hands.send({image: video})}, width: 320, height: 240});
            cam.start();
            render();
        }

        function render() {
            requestAnimationFrame(render);
            // 实现平滑过渡
            currentRotation += (targetRotation - currentRotation) * 0.1;
            treeGroup.rotation.y = currentRotation;
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
