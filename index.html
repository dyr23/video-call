<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>éš”ç©ºæ§æ ‘äº¤äº’ç³»ç»Ÿ</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js" type="module"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; background: #000; overflow: hidden; }
        #video-container { position: absolute; bottom: 20px; right: 20px; width: 120px; height: 90px; border: 2px solid #3b82f6; border-radius: 10px; overflow: hidden; z-index: 100; transform: scaleX(-1); }
        video { width: 100%; height: 100%; object-fit: cover; }
    </style>
</head>
<body>

    <div id="video-container">
        <video id="input-video"></video>
    </div>

    <div class="absolute top-10 left-0 w-full text-center z-50 pointer-events-none">
        <h1 class="text-white text-2xl font-bold tracking-widest drop-shadow-lg">éš”ç©ºæ—‹è½¬äº’åŠ¨æ ‘</h1>
        <p id="status" class="text-blue-400 mt-2">æ­£åœ¨åˆå§‹åŒ–æ‘„åƒå¤´...</p>
    </div>

    <script type="module">
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js';

        let scene, camera, renderer, treeGroup;
        let lastHandX = null;
        const videoElement = document.getElementById('input-video');
        const statusText = document.getElementById('status');

        // --- 1. åˆå§‹åŒ– 3D åœºæ™¯ ---
        function initThree() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 2, 5);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            const light = new THREE.DirectionalLight(0xffffff, 1);
            light.position.set(1, 1, 2);
            scene.add(light);
            scene.add(new THREE.AmbientLight(0xffffff, 0.5));

            // åˆ›å»ºä¸€æ£µç®€å•çš„æ ‘
            treeGroup = new THREE.Group();
            const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.4, 3), new THREE.MeshPhongMaterial({color: 0x8B4513}));
            treeGroup.add(trunk);
            const canopy = new THREE.Mesh(new THREE.SphereGeometry(1.5, 16, 16), new THREE.MeshPhongMaterial({color: 0x228B22}));
            canopy.position.y = 2.5;
            treeGroup.add(canopy);
            
            scene.add(treeGroup);
        }

        // --- 2. åˆå§‹åŒ–æ‰‹åŠ¿è¯†åˆ« ---
        const hands = new Hands({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
        });

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults((results) => {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                statusText.innerText = "ğŸ™Œ å·²æ£€æµ‹åˆ°æ‰‹åŠ¿ - å·¦å³ç§»åŠ¨è¯•ä¸€è¯•";
                const hand = results.multiHandLandmarks[0];
                // ä½¿ç”¨é£ŸæŒ‡æŒ‡å°– (Landmark 8) çš„ X åæ ‡
                const currentHandX = hand[8].x;

                if (lastHandX !== null) {
                    const deltaX = currentHandX - lastHandX;
                    
                    // --- é€Ÿåº¦æ§åˆ¶æ ¸å¿ƒ ---
                    // è¿™é‡Œä¹˜æ•°è¶Šå¤§ï¼Œè½¬å¾—è¶Šå¿«ï¼ä½ å¯ä»¥æŠŠ 15 æ”¹æˆ 30 ç”šè‡³æ›´é«˜ã€‚
                    const sensitivity = 20; 
                    treeGroup.rotation.y += deltaX * sensitivity;
                }
                lastHandX = currentHandX;
            } else {
                statusText.innerText = "è¯·å°†æ‰‹å±•ç¤ºåœ¨æ‘„åƒå¤´å‰";
                lastHandX = null;
            }
        });

        const cameraFeed = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 640,
            height: 480
        });

        // å¯åŠ¨
        initThree();
        cameraFeed.start();

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
